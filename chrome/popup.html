<style>
body {
  overflow-x:hidden;
  width : 180px;
}

#menu {
    display: none;
};

.item {
    display: block;
    margin-bottom : 5px;
}

.label {
    display: inline-block;
    width: 2em;
    border-right: 1px solid #DDD;
    margin-right: 5px;

    height: 40px;
    vertical-align:top;
}

.label span {
    line-height : 40px;
}

.screen {
    height: 50px;
    display: inline-block;
}

.win {
    display: inline-block;
    border-color: #4B8CDC;
    border-style:solid;
    border-width : 1px 1px 1px 1px;
    height : 40px;
    margin-right : 5px;
}

.win:hover {
    background-color : yellow;
}

.win30 {
    width : 30px;
}

.win40 {
    width : 40px;
}

.win50 {
    width : 50px;
}

.win60 {
    width : 60px;
}

.win70 {
    width : 70px;
}

.win100 {
    width : 111px;
}

#message {
    display : none;
};

</style>

<script src="jquery-1.7.1.min.js"></script>
<script>

/// The current tab
var currentTab;

/// The current win
var currentWin;

/// The background page
var bg = chrome.extension.getBackgroundPage(); 

function isMaximized(win) {
	var res;

	var os = bg.detectOS();

    // I would like to know a better way to detect the maximized state...
	if (os == "Windows") {
		res = (win.left == -8 && win.top == -8 && win.width == window.screen.availWidth + 16);
	} else {
		res = (win.left == 0 && win.width == window.screen.availWidth);
	}
	
    return res;
}

/// Calculate the rectangles of screen aftered splitted with ratio
function calcRect(ratio) {
    var left = 0;
    var top = 0;
    var width = parseInt(window.screen.availWidth * ratio / 10);
    var height = window.screen.availHeight;

    var rect1 = {
        left : left,
        top : top,
        width : width,
        height : height
    };

    var rect2 = {
        left : width + 1,
        top : top,
        width : window.screen.availWidth - width,
        height : height
    };

    return [rect1,rect2];
}

/// Create a window and move the current tab to the new window. 
function createAndMove(ratio,order) {
    var rect;
    var winId = currentTab.windowId;
    var rects = calcRect(ratio);

    rect = rects[1 - order];
    chrome.windows.update(winId,rect);

    rect = rects[order];
    rect["tabId"] = currentTab.id;
    chrome.windows.create(rect,function(win2) {
        bg.save(winId,win2.id);
    });
}

/// Arrange the location of windows
function arrange(ratio,order,list) {
    var rects = calcRect(ratio);
    var rect;
    
    var currWinId = currentTab.windowId;
    var targetWinId;
    
    var savedWindows = bg.load();
    var i = 0;

    for ( i = 0 ; i < list.length;i++){
        var win = list[i];
        
        if (win.id == currWinId)
            continue;
            
        if (targetWinId == undefined) {
            // Random pick a one if saved Window is absent
            targetWinId = win.id;
        }
        
        if (win.id == savedWindows[0] ||
            win.id == savedWindows[1]){
            targetWinId = win.id;
            break;
        }
    }    

    var targetWinRect = rects[1 - order];
    targetWinRect.focused = true;
    var currentWinRect = rects[order];
    currentWinRect.focused = true;

	chrome.windows.update(targetWinId,targetWinRect);
	chrome.windows.update(currWinId,currentWinRect);
    bg.save(currWinId,targetWinId);
	// Nested call after update() do not works on windows Chrome.. It is wierd..
	/*
    chrome.windows.update(targetWinId,targetWinRect,function() {
        chrome.windows.update(currWinId,currentWinRect,function() {
           bg.save(currWinId,targetWinId);
        });
    });
	*/
}

/// Split the window into two
function splitWin(ratio,order) {
    chrome.windows.getAll({},function(list) {
       var filtered = [];
       var i = 0;
       for ( i = 0 ; i < list.length;i++){
           if (!isMaximized(list[i]))
               filtered.push(list[i]);
       }
        
       if (filtered.length == 1 ) { 
           // If no. of window is one , it could create new window
           createAndMove(ratio,order);   
       } else {
           // More than one window. It should reuse the already existed windows.
           arrange(ratio,order,filtered);
       }
    });
}

/// Merge windows. An opposite operation of splitWin
function mergeWin() {
    chrome.windows.getAll({populate : true},function(windows) {

        var list = [];
        
        var saved = bg.load();
        var i,j ;
        
        var other;
        var current; // the current window. Unlike currentWin. It did contains the tabs information
        
        for (i = 0 ; i  < windows.length;i++) {
            if (currentWin.id == windows[i].id) {
                current = windows[i];
                continue;
            }
            for (j = 0 ; j < saved.length;j++){
                if (windows[i].id == saved[j]) {
                    other = windows[i];
                }
            }
        }
        
        var rect = {
            left : 1,
            top : 1,
            width : window.screen.availWidth - 2,
            height : window.screen.availHeight - 2
        }; // not really maximized. Call isMaximized() of resized window will return false
        
        chrome.windows.update(currentWin.id , rect);
        
        if (other != undefined) {
            var tabs = []
            $(other.tabs).each(function(idx,tab) {
                tabs.push(tab.id);
            });
            chrome.tabs.move(tabs,{windowId: currentWin.id , index: current.tabs.length} );
        }
        
        bg.clear();
    });
}

/// Report the current status (for debugging)
function report() {
    //$(document.createElement("div")).text("Last Tab: " + String(bg.lastTab) ).prependTo("body");
    $(document.createElement("div")).text("OS: " + String(bg.detectOS()) ).prependTo("body");
    $(document.createElement("div")).text("Last Window: " + String(bg.lastWindows) ).prependTo("body"); 
    $(document.createElement("div")).text("Current Window ID: " + String(currentWin.id) ).prependTo("body");
    $(document.createElement("div")).text("Window Rect: " + currentWin.left + " "  +  currentWin.top + " " + String(currentWin.width) + " " + String(currentWin.height) ).prependTo("body");
    $(document.createElement("div")).text("Window Avail Size: " + String(window.screen.availWidth) + " " + String(window.screen.availHeight) ).prependTo("body");
    chrome.windows.getAll({} , function(list) {
        $(document.createElement("div")).text("No. of windows: " + String(list.length) ).prependTo("body");
        var filtered = [];
        var i = 0;
        for ( i = 0 ; i < list.length;i++){
            if (!isMaximized(list[i]))
                filtered.push(list[i]);
        }
        $(document.createElement("div")).text("No. of unmaximized windows: " + String(filtered.length) ).prependTo("body");

    });
}

/// Show the paired window
function showPair(id) {
    var list = bg.load();
    
    var i = 0, j = -1;
    for (i = 0 ; i < list.length;i++){
        if (list[i] == id){
            j = i;
            break;
        }
    }   
    
    if (j!=-1){
        chrome.windows.get(list[1 - j] , function(win) {
            if (win!=undefined) {
                chrome.windows.update(list[1 - j] , {focused: true});
                chrome.windows.update(list[j] , {focused: true});
            }
        });
    }
    
}

/// Setup the popup content
function setup() {
    // Array of available ratio with order = 0
    var arr = [5,7,6,3,4];      
   
    $(arr).each(function(idx,ratio) {
        var id = "#split" + ratio + "_0";
        $(id).click(function() { splitWin(ratio,0);});      
        id = "#split" + ratio + "_1";
        $(id).click(function() { splitWin(10 - ratio,1);});      
    });   
    
    $("#merge").click(mergeWin);
   
    if (isMaximized(currentWin)) { 
        $("#message").css("display","block");
    } else {    
        $("#menu").css("display","block");        
        //showPair(currentWin.id);
    }

    //report();
}

$(document).ready(function() {
    chrome.tabs.getSelected(null,function(tab) {
       chrome.windows.get(tab.windowId,function(win) {
            currentTab = tab;
            currentWin = win;
            setup();
       });
    });
});

</script>

<body>

<div id="menu">

<div class="item">
<div class="label"><span>7:3</span></div>
<div class="screen">
<div class="win win70" id="split7_0"></div> <div class="win win30" id="split3_1"></div>
</div>
</div>

<div class="item">
<div class="label"><span>6:4</span></div>
<div class="screen">
<div class="win win60" id="split6_0"></div> <div class="win win40" id="split4_1"></div>
</div>
</div>

<div class="item">
<div class="label"><span>5:5</span></div>
<div class="screen"><div class="win win50" id="split5_0"></div> <div class="win win50" id="split5_1"></div></div>
</div>

<div class="item">
<div class="label"><span>4:6</span></div>
<div class="screen">
<div class="win win40" id="split4_0"></div> <div class="win win60" id="split6_1"></div>
</div>
</div>

<div class="item">
<div class="label"><span>3:7</span></div>
<div class="screen">
<div class="win win30" id="split3_0"></div> <div class="win win70" id="split7_1"></div>
</div>
</div>

<div class="item">
<div class="label" align="center"><span>1</span></div>
<div class="screen">
<div class="win win100" id="merge"></div> 
</div>
</div>

</div> <!-- End of menu -->

<div id="message"> Dualless do not support maximized window. Please un-maximize it first.</div>

</body>
